qt-bugs@ issue : 167704
Trolltech task ID : 168283 (status: "fixed" for Qt 4.4.0, but effectively refused)
bugs.kde.org number : none
applied: no
author: Lubos Lunak <l.lunak@kde.org>

NOTE: It is suggested to apply patch #0209 as well when this patch is used.

This patch uses object name as a fallback for window role if no window role
is set explicitly using setWindowRole(). Since Qt3 always used the object
name as the window role and most Qt3/KDE3 code is ported to call setObjectName(),
this makes the window role set in many cases (which KWin uses for window identifying).


--- a/src/corelib/kernel/qobject.cpp
+++ b/src/corelib/kernel/qobject.cpp
@@ -1016,9 +1016,18 @@
 {
     Q_D(QObject);
     d->objectName = name;
+#if defined(Q_WS_X11)
+    d->checkWindowRole();
+#endif
 }
 
 
+#if defined(Q_WS_X11)
+void QObjectPrivate::checkWindowRole()
+{
+}
+#endif
+
 #ifdef QT3_SUPPORT
 /*! \internal
     QObject::child is compat but needs to call itself recursively,
--- a/src/corelib/kernel/qobject_p.h
+++ b/src/corelib/kernel/qobject_p.h
@@ -146,6 +146,9 @@
     mutable quint32 connectedSignals;
 
     QString objectName;
+#if defined(Q_WS_X11)
+    virtual void checkWindowRole();
+#endif
 
     // Note: you must hold the signalSlotLock() before accessing the lists below or calling the functions
     struct Connection
--- a/src/gui/kernel/qwidget_p.h
+++ b/src/gui/kernel/qwidget_p.h
@@ -328,6 +328,7 @@
 
 #if defined(Q_WS_X11)
     void setWindowRole();
+    virtual void checkWindowRole();
     void sendStartupMessage(const char *message) const;
     void setNetWmWindowTypes();
 #endif
--- a/src/gui/kernel/qwidget_x11.cpp
+++ b/src/gui/kernel/qwidget_x11.cpp
@@ -714,13 +714,17 @@
         data.fstrut_dirty = 1;
 
         // declare the widget's window role
+        QByteArray windowRole;
         if (QTLWExtra *topData = maybeTopData()) {
-            if (!topData->role.isEmpty()) {
-                QByteArray windowRole = topData->role.toUtf8();
-                XChangeProperty(dpy, id,
-                                ATOM(WM_WINDOW_ROLE), XA_STRING, 8, PropModeReplace,
-                                (unsigned char *)windowRole.constData(), windowRole.length());
-            }
+            if (!topData->role.isEmpty())
+                windowRole = topData->role.toUtf8();
+        }
+        if (windowRole.isEmpty()) // use object name as a fallback
+            windowRole = objectName.toUtf8();
+        if (!windowRole.isEmpty()) {
+            XChangeProperty(dpy, id,
+                            ATOM(WM_WINDOW_ROLE), XA_STRING, 8, PropModeReplace,
+                            (unsigned char *)windowRole.constData(), windowRole.length());
         }
 
         // set client leader property
@@ -2857,6 +2861,17 @@
                     (unsigned char *)windowRole.constData(), windowRole.length());
 }
 
+void QWidgetPrivate::checkWindowRole()
+{
+    Q_Q(QWidget);
+    if( !q->windowRole().isEmpty() || !q->internalWinId())
+        return;
+    QByteArray windowRole = objectName.toUtf8(); // use as a fallback
+    XChangeProperty(X11->display, q->internalWinId(),
+                    ATOM(WM_WINDOW_ROLE), XA_STRING, 8, PropModeReplace,
+                    (unsigned char *)windowRole.constData(), windowRole.length());
+}
+
 Q_GLOBAL_STATIC(QX11PaintEngine, qt_widget_paintengine)
 QPaintEngine *QWidget::paintEngine() const
 {
