qt-bugs@ issue : none, in Qt 4.4 already
Trolltech task ID : 120338
applied: no
author: Zack Rusin <zrusin@trolltech.com>
os: unix

Fixes:    Qt handling argb visuals on X11
Details:  we make Qt pick ARGB visuals when available.
this allows people writing properly semi-transparent
apps on X11.

--- qt4-x11-4.3.1.orig/src/gui/kernel/qapplication_x11.cpp
+++ qt4-x11-4.3.1/src/gui/kernel/qapplication_x11.cpp
@@ -1567,6 +1567,30 @@
                            / (DisplayHeightMM(X11->display, s)*10);
         }
 
+
+#ifndef QT_NO_XRENDER
+        int xrender_eventbase,  xrender_errorbase;
+        // See if XRender is supported on the connected display
+        if (XQueryExtension(X11->display, "RENDER", &X11->xrender_major,
+                            &xrender_eventbase, &xrender_errorbase)
+            && XRenderQueryExtension(X11->display, &xrender_eventbase,
+                                     &xrender_errorbase)) {
+            // Check the version as well - we need v0.4 or higher
+            int major = 0;
+            int minor = 0;
+            XRenderQueryVersion(X11->display, &major, &minor);
+            if (qgetenv("QT_X11_NO_XRENDER").isNull()) {
+                X11->use_xrender = (major >= 0 && minor >= 5);
+                X11->xrender_version = major*100+minor;
+                // workaround for broken XServer on Ubuntu Breezy (6.8 compiled with 7.0
+                // protocol headers)
+                if (X11->xrender_version == 10
+                    && VendorRelease(X11->display) < 60900000
+                    && QByteArray(ServerVendor(X11->display)).contains("X.Org"))
+                    X11->xrender_version = 9;
+            }
+        }
+#endif // QT_NO_XRENDER
         QColormap::initialize();
 
         // Support protocols
@@ -1590,30 +1614,15 @@
 #endif // QT_NO_XRANDR
 
 #ifndef QT_NO_XRENDER
-        int xrender_eventbase,  xrender_errorbase;
-        // See if XRender is supported on the connected display
-        if (XQueryExtension(X11->display, "RENDER", &X11->xrender_major,
-                            &xrender_eventbase, &xrender_errorbase)
-            && XRenderQueryExtension(X11->display, &xrender_eventbase,
-                                     &xrender_errorbase)) {
+        if (X11->use_xrender) {
             // XRender is supported, let's see if we have a PictFormat for the
             // default visual
             XRenderPictFormat *format =
                 XRenderFindVisualFormat(X11->display,
                                         (Visual *) QX11Info::appVisual(X11->defaultScreen));
-            // Check the version as well - we need v0.4 or higher
-            int major = 0;
-            int minor = 0;
-            XRenderQueryVersion(X11->display, &major, &minor);
-            if (qgetenv("QT_X11_NO_XRENDER").isNull() && format != 0) {
-                X11->use_xrender = (major >= 0 && minor >= 5);
-                X11->xrender_version = major*100+minor;
-                // workaround for broken XServer on Ubuntu Breezy (6.8 compiled with 7.0
-                // protocol headers)
-                if (X11->xrender_version == 10
-                    && VendorRelease(X11->display) < 60900000
-                    && QByteArray(ServerVendor(X11->display)).contains("X.Org"))
-                    X11->xrender_version = 9;
+
+            if (!format) {
+                X11->use_xrender = false;
             }
         }
 #endif // QT_NO_XRENDER
--- qt4-x11-4.3.1.orig/src/gui/kernel/qwidget_x11.cpp
+++ qt4-x11-4.3.1/src/gui/kernel/qwidget_x11.cpp
@@ -555,7 +555,7 @@
         picture = 0;
     }
 
-    if (X11->use_xrender) {
+    if (X11->use_xrender && !desktop) {
         XRenderPictFormat *format = XRenderFindVisualFormat(dpy, (Visual *) xinfo.visual());
         if (format)
             picture = XRenderCreatePicture(dpy, id, format, 0, 0);
--- qt4-x11-4.3.1.orig/src/gui/painting/qcolormap_x11.cpp
+++ qt4-x11-4.3.1/src/gui/painting/qcolormap_x11.cpp
@@ -401,7 +401,33 @@
         } else if (!X11->custom_cmap) {
             XStandardColormap *stdcmap = 0;
             int ncmaps = 0;
-            if (XGetRGBColormaps(display, RootWindow(display, i),
+
+            bool foundArgbVisual = false;
+#ifndef QT_NO_XRENDER
+            if (X11->use_xrender) {
+                int nvi;
+                XVisualInfo templ;
+                templ.screen  = i;
+                templ.depth   = 32;
+                templ.c_class = TrueColor;
+                XVisualInfo *xvi = XGetVisualInfo(X11->display, VisualScreenMask |
+                                                  VisualDepthMask |
+                                                  VisualClassMask, &templ, &nvi);
+                for (int idx = 0; idx < nvi; ++idx) {
+                    XRenderPictFormat *format = XRenderFindVisualFormat(X11->display,
+                                                                        xvi[idx].visual);
+                    if (format->type == PictTypeDirect && format->direct.alphaMask) {
+                        d->visual = xvi[idx].visual;
+                        d->depth = 32;
+                        d->defaultVisual = false;
+                        foundArgbVisual = true;
+                        break;
+                    }
+                }
+            }
+#endif
+            if (!foundArgbVisual &&
+                XGetRGBColormaps(display, RootWindow(display, i),
                                  &stdcmap, &ncmaps, XA_RGB_DEFAULT_MAP)) {
                 if (stdcmap) {
                     for (int c = 0; c < ncmaps; ++c) {
@@ -459,7 +485,6 @@
                 }
             }
         }
-
         if (!use_stdcmap) {
             switch (d->visual->c_class) {
             case StaticGray:
