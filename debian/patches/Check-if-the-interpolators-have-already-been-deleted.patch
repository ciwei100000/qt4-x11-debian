From 861333040c252fa0f53894b604f7cb768c085281 Mon Sep 17 00:00:00 2001
From: Thiago Macieira <thiago.macieira@nokia.com>
Date: Wed, 26 Jan 2011 14:06:11 +0100
Subject: [PATCH] Check if the interpolators have already been deleted.

During application destruction, the order in which static destructors
is run is undetermined. So avoid a null-pointer dereference.

Task-number: QTBUG-16855
Reviewed-by: Robin Burchell
Patch by task reporter
---
 src/corelib/animation/qvariantanimation.cpp |   13 +++++++++----
 1 files changed, 9 insertions(+), 4 deletions(-)

diff --git a/src/corelib/animation/qvariantanimation.cpp b/src/corelib/animation/qvariantanimation.cpp
index 212e85d..c76cb89 100644
--- a/src/corelib/animation/qvariantanimation.cpp
+++ b/src/corelib/animation/qvariantanimation.cpp
@@ -431,12 +431,17 @@ void QVariantAnimation::registerInterpolator(QVariantAnimation::Interpolator fun
 {
     // will override any existing interpolators
     QInterpolatorVector *interpolators = registeredInterpolators();
+    // When built on solaris with GCC, the destructors can be called
+    // in such an order that we get here with interpolators == NULL,
+    // to continue causes the app to crash on exit with a SEGV
+    if (interpolators) {
 #ifndef QT_NO_THREAD
-    QMutexLocker locker(QMutexPool::globalInstanceGet(interpolators));
+        QMutexLocker locker(QMutexPool::globalInstanceGet(interpolators));
 #endif
-    if (int(interpolationType) >= interpolators->count())
-        interpolators->resize(int(interpolationType) + 1);
-    interpolators->replace(interpolationType, func);
+        if (int(interpolationType) >= interpolators->count())
+            interpolators->resize(int(interpolationType) + 1);
+        interpolators->replace(interpolationType, func);
+    }
 }
 
 
-- 
1.7.5.4

