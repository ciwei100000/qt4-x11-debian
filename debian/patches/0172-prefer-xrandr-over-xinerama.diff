qt-bugs@ issue :  N198137
Trolltech task ID : none
bugs.kde.org number :
applied: no
author: Dirk Mueller <mueller@kde.org>

only trust libxinerama if its not the emulated information
coming from xrandr 1.2. xrandr 1.2 is merged fb and libxinerama
presents then virtual screens in clone mode, which qt (and KDE)
can't deal with.

proper fix would be to detect crtcs as virtual screens, but
given that qt can't deal with dynamically changing number of screens,
this is for "when I have time".

also includes a race fix that can cause the whole KDE session to crash
when you resize the screen.

it also includes a fix for a bug that causes the whole KDE session to crash
when you remove a CRTc.

--- a/src/gui/kernel/qdesktopwidget_x11.cpp
+++ b/src/gui/kernel/qdesktopwidget_x11.cpp
@@ -118,7 +118,7 @@
             screens[i] = 0;
         }
 
-        delete [] screens;
+        free (screens);
     }
 
     if (rects)     delete [] rects;
@@ -128,10 +128,10 @@
 void QDesktopWidgetPrivate::init()
 {
     // get the screen count
+    int newScreenCount;
 #ifndef QT_NO_XINERAMA
 
     XineramaScreenInfo *xinerama_screeninfo = 0;
-
     if (X11->ptrXineramaQueryExtension
         && X11->ptrXineramaIsActive
         && X11->ptrXineramaQueryScreens) {
@@ -140,25 +140,28 @@
                         && X11->ptrXineramaIsActive(X11->display));
     }
 
-    if (use_xinerama) {
+    if (use_xinerama)
         xinerama_screeninfo =
-            X11->ptrXineramaQueryScreens(X11->display, &screenCount);
+            X11->ptrXineramaQueryScreens(X11->display, &newScreenCount);
+
+    if (xinerama_screeninfo) {
         defaultScreen = 0;
      } else
 #endif // QT_NO_XINERAMA
     {
         defaultScreen = DefaultScreen(X11->display);
-        screenCount = ScreenCount(X11->display);
+        newScreenCount = ScreenCount(X11->display);
+        use_xinerama = false;
     }
 
     delete [] rects;
-    rects     = new QRect[screenCount];
+    rects     = new QRect[newScreenCount];
     delete [] workareas;
-    workareas = new QRect[screenCount];
+    workareas = new QRect[newScreenCount];
 
     // get the geometry of each screen
-    int i, x, y, w, h;
-    for (i = 0; i < screenCount; i++) {
+    int i, j, x, y, w, h;
+    for (i = 0, j = 0; i < newScreenCount; i++, j++) {
 
 #ifndef QT_NO_XINERAMA
         if (use_xinerama) {
@@ -175,11 +178,29 @@
                 h = HeightOfScreen(ScreenOfDisplay(X11->display, i));
             }
 
-        rects[i].setRect(x, y, w, h);
+        rects[j].setRect(x, y, w, h);
+        if (j > 0 && rects[j-1].intersects(rects[j]) &&
+                (rects[j].width()*rects[j].height()) >
+                (rects[j-1].width()*rects[j-1].height())) {
+            rects[j-1] = rects[j];
+           j--;
+        }
         workareas[i] = QRect();
     }
 
+    if (screens) {
+        // leaks QWidget* pointers on purpose, can't delete them as pointer escapes
+        screens = (QWidget**) realloc(screens, j * sizeof(QWidget*));
+        if (j > screenCount)
+            memset(&screens[screenCount], 0, (j-screenCount) * sizeof(QWidget*));
+    }
+
+    screenCount = j;
+
 #ifndef QT_NO_XINERAMA
+    if (use_xinerama && screenCount == 1)
+        use_xinerama = false;
+
     if (xinerama_screeninfo)
         XFree(xinerama_screeninfo);
 #endif // QT_NO_XINERAMA
@@ -227,8 +248,7 @@
         screen = d->defaultScreen;
 
     if (! d->screens) {
-        d->screens = new QWidget*[d->screenCount];
-        memset(d->screens, 0, d->screenCount * sizeof(QWidget *));
+        d->screens = (QWidget**) calloc( d->screenCount, sizeof(QWidget*));
         d->screens[d->defaultScreen] = this;
     }
 
