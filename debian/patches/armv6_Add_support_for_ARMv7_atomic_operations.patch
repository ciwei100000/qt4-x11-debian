Description: Add support for ARMv7 atomic operations

    ARMv7 adds the DMB (data memory barrier) instruction which we can use to
    enforce memory barriers in QAtomicInt and QAtomicPointer. Other than
    that, ARMv7 is identical to ARMv6.
    
    Adjust the ARMv6 code to relax the compiler memory barriers on the
    *Relaxed() operations, and use *Relaxed() functions together the
    appropriate compiler barriers in the *Acquire(), *Release(), and
    *Ordered() functions. For "pure" ARMv6 code, the barriers are only
    compiler barriers, but for ARMv7, we also emit the DMB instruction.

    Fixed in Qt 4.8. See patchset:
    f293b98  Silence preprocessor warnings about __TARGET_ARCH_ARM not being
             defined
    c7bf2d7  Fixed compile for symbian
    dc8d096  Compile when detecting ARMv5
    2c73f55  Compile when detecting ARMv5
    82b4fff  Add support for ARMv7 atomic operations
    7be2c58  Merge the armv6 and arm architectures
    1c0b3237 Copy src/corelib/arch/qatomic_arm.h to
             src/corelib/arch/qatomic_armv5.h
    a0f69c0  Move symbian specific qatomic_generic_armv6.cpp

Author: Bradley T. Hughes <bradley.hughes@nokia.com>
Bug-Ubuntu: https://launchpad.net/bugs/490371
---
 src/corelib/arch/qatomic_armv6.h |  162 ++++++++++++++++++++++++++-------------
 1 file changed, 111 insertions(+), 51 deletions(-)

--- a/src/corelib/arch/qatomic_armv6.h
+++ b/src/corelib/arch/qatomic_armv6.h
@@ -102,6 +102,15 @@ Q_INLINE_TEMPLATE bool QBasicAtomicPoint
 
 #ifndef Q_CC_RVCT
 
+// use the DMB instruction when compiling for ARMv7
+#ifndef Q_DATA_MEMORY_BARRIER
+# define Q_DATA_MEMORY_BARRIER asm volatile("dmb\n":::"memory")
+#endif
+#ifndef Q_COMPILER_MEMORY_BARRIER
+# define Q_COMPILER_MEMORY_BARRIER asm volatile("":::"memory")
+#endif
+
+// ... but the implementation is otherwise identical to that for ARMv6
 inline bool QBasicAtomicInt::ref()
 {
     register int newValue;
@@ -138,7 +147,7 @@ inline bool QBasicAtomicInt::deref()
     return newValue != 0;
 }
 
-inline bool QBasicAtomicInt::testAndSetOrdered(int expectedValue, int newValue)
+inline bool QBasicAtomicInt::testAndSetRelaxed(int expectedValue, int newValue)
 {
     register int result;
     asm volatile("0:\n"
@@ -153,11 +162,11 @@ inline bool QBasicAtomicInt::testAndSetO
                  : [expectedValue] "r" (expectedValue),
                    [newValue] "r" (newValue),
                    [_q_value] "r" (&_q_value)
-                 : "cc", "memory");
+                 : "cc");
     return result == 0;
 }
 
-inline int QBasicAtomicInt::fetchAndStoreOrdered(int newValue)
+inline int QBasicAtomicInt::fetchAndStoreRelaxed(int newValue)
 {
     register int originalValue;
     register int result;
@@ -171,11 +180,11 @@ inline int QBasicAtomicInt::fetchAndStor
                    "+m" (_q_value)
                  : [newValue] "r" (newValue),
                    [_q_value] "r" (&_q_value)
-                 : "cc", "memory");
+                 : "cc");
     return originalValue;
 }
 
-inline int QBasicAtomicInt::fetchAndAddOrdered(int valueToAdd)
+inline int QBasicAtomicInt::fetchAndAddRelaxed(int valueToAdd)
 {
     register int originalValue;
     register int newValue;
@@ -192,12 +201,12 @@ inline int QBasicAtomicInt::fetchAndAddO
                    "+m" (_q_value)
                  : [valueToAdd] "r" (valueToAdd),
                    [_q_value] "r" (&_q_value)
-                 : "cc", "memory");
+                 : "cc");
     return originalValue;
 }
 
 template <typename T>
-Q_INLINE_TEMPLATE bool QBasicAtomicPointer<T>::testAndSetOrdered(T *expectedValue, T *newValue)
+Q_INLINE_TEMPLATE bool QBasicAtomicPointer<T>::testAndSetRelaxed(T *expectedValue, T *newValue)
 {
     register T *result;
     asm volatile("0:\n"
@@ -212,12 +221,12 @@ Q_INLINE_TEMPLATE bool QBasicAtomicPoint
                  : [expectedValue] "r" (expectedValue),
                    [newValue] "r" (newValue),
                    [_q_value] "r" (&_q_value)
-                 : "cc", "memory");
+                 : "cc");
     return result == 0;
 }
 
 template <typename T>
-Q_INLINE_TEMPLATE T *QBasicAtomicPointer<T>::fetchAndStoreOrdered(T *newValue)
+Q_INLINE_TEMPLATE T *QBasicAtomicPointer<T>::fetchAndStoreRelaxed(T *newValue)
 {
     register T *originalValue;
     register int result;
@@ -231,12 +240,12 @@ Q_INLINE_TEMPLATE T *QBasicAtomicPointer
                    "+m" (_q_value)
                  : [newValue] "r" (newValue),
                    [_q_value] "r" (&_q_value)
-                 : "cc", "memory");
+                 : "cc");
     return originalValue;
 }
 
 template <typename T>
-Q_INLINE_TEMPLATE T *QBasicAtomicPointer<T>::fetchAndAddOrdered(qptrdiff valueToAdd)
+Q_INLINE_TEMPLATE T *QBasicAtomicPointer<T>::fetchAndAddRelaxed(qptrdiff valueToAdd)
 {
     register T *originalValue;
     register T *newValue;
@@ -253,7 +262,7 @@ Q_INLINE_TEMPLATE T *QBasicAtomicPointer
                    "+m" (_q_value)
                  : [valueToAdd] "r" (valueToAdd * sizeof(T)),
                    [_q_value] "r" (&_q_value)
-                 : "cc", "memory");
+                 : "cc");
     return originalValue;
 }
 
@@ -265,9 +274,18 @@ Q_INLINE_TEMPLATE T *QBasicAtomicPointer
 // RVCT embedded assembly documentation:
 // http://www.keil.com/support/man/docs/armcc/armcc_chddbeib.htm
 
-// save our pragma state and switch to ARM mode
-#pragma push
-#pragma arm
+#if __TARGET_ARCH_THUMB-0 < 4
+// save our pragma state and switch to ARM mode (unless using Thumb2)
+# pragma push
+# pragma arm
+#endif
+
+#ifndef Q_DATA_MEMORY_BARRIER
+# define Q_DATA_MEMORY_BARRIER __schedule_barrier()
+#endif
+#ifndef Q_COMPILER_MEMORY_BARRIER
+# define Q_COMPILER_MEMORY_BARRIER __schedule_barrier()
+#endif
 
 inline bool QBasicAtomicInt::ref()
 {
@@ -299,7 +317,7 @@ inline bool QBasicAtomicInt::deref()
     return newValue != 0;
 }
 
-inline bool QBasicAtomicInt::testAndSetOrdered(int expectedValue, int newValue)
+inline bool QBasicAtomicInt::testAndSetRelaxed(int expectedValue, int newValue)
 {
     register int result;
     retry:
@@ -313,7 +331,7 @@ inline bool QBasicAtomicInt::testAndSetO
     return result == 0;
 }
 
-inline int QBasicAtomicInt::fetchAndStoreOrdered(int newValue)
+inline int QBasicAtomicInt::fetchAndStoreRelaxed(int newValue)
 {
     register int originalValue;
     register int result;
@@ -327,7 +345,7 @@ inline int QBasicAtomicInt::fetchAndStor
     return originalValue;
 }
 
-inline int QBasicAtomicInt::fetchAndAddOrdered(int valueToAdd)
+inline int QBasicAtomicInt::fetchAndAddRelaxed(int valueToAdd)
 {
     register int originalValue;
     register int newValue;
@@ -344,7 +362,7 @@ inline int QBasicAtomicInt::fetchAndAddO
 }
 
 template <typename T>
-Q_INLINE_TEMPLATE bool QBasicAtomicPointer<T>::testAndSetOrdered(T *expectedValue, T *newValue)
+Q_INLINE_TEMPLATE bool QBasicAtomicPointer<T>::testAndSetRelaxed(T *expectedValue, T *newValue)
 {
     register T *result;
     retry:
@@ -359,7 +377,7 @@ Q_INLINE_TEMPLATE bool QBasicAtomicPoint
 }
 
 template <typename T>
-Q_INLINE_TEMPLATE T *QBasicAtomicPointer<T>::fetchAndStoreOrdered(T *newValue)
+Q_INLINE_TEMPLATE T *QBasicAtomicPointer<T>::fetchAndStoreRelaxed(T *newValue)
 {
     register T *originalValue;
     register int result;
@@ -374,7 +392,7 @@ Q_INLINE_TEMPLATE T *QBasicAtomicPointer
 }
 
 template <typename T>
-Q_INLINE_TEMPLATE T *QBasicAtomicPointer<T>::fetchAndAddOrdered(qptrdiff valueToAdd)
+Q_INLINE_TEMPLATE T *QBasicAtomicPointer<T>::fetchAndAddRelaxed(qptrdiff valueToAdd)
 {
     register T *originalValue;
     register T *newValue;
@@ -390,111 +408,153 @@ Q_INLINE_TEMPLATE T *QBasicAtomicPointer
     return originalValue;
 }
 
-// go back to the previous pragma state (probably Thumb mode)
-#pragma pop
+#if __TARGET_ARCH_THUMB-0 < 4
+# pragma pop
 #endif
 
-// common code
+#endif
 
-inline bool QBasicAtomicInt::testAndSetRelaxed(int expectedValue, int newValue)
-{
-    return testAndSetOrdered(expectedValue, newValue);
-}
+// common code
 
 inline bool QBasicAtomicInt::testAndSetAcquire(int expectedValue, int newValue)
 {
-    return testAndSetOrdered(expectedValue, newValue);
+    bool returnValue = testAndSetRelaxed(expectedValue, newValue);
+    Q_DATA_MEMORY_BARRIER;
+    return returnValue;
 }
 
 inline bool QBasicAtomicInt::testAndSetRelease(int expectedValue, int newValue)
 {
-    return testAndSetOrdered(expectedValue, newValue);
+    Q_DATA_MEMORY_BARRIER;
+    return testAndSetRelaxed(expectedValue, newValue);
 }
 
-inline int QBasicAtomicInt::fetchAndStoreRelaxed(int newValue)
+inline bool QBasicAtomicInt::testAndSetOrdered(int expectedValue, int newValue)
 {
-    return fetchAndStoreOrdered(newValue);
+    Q_DATA_MEMORY_BARRIER;
+    bool returnValue = testAndSetRelaxed(expectedValue, newValue);
+    Q_COMPILER_MEMORY_BARRIER;
+    return returnValue;
 }
 
 inline int QBasicAtomicInt::fetchAndStoreAcquire(int newValue)
 {
-    return fetchAndStoreOrdered(newValue);
+    int returnValue = fetchAndStoreRelaxed(newValue);
+    Q_DATA_MEMORY_BARRIER;
+    return returnValue;
 }
 
 inline int QBasicAtomicInt::fetchAndStoreRelease(int newValue)
 {
-    return fetchAndStoreOrdered(newValue);
+    Q_DATA_MEMORY_BARRIER;
+    return fetchAndStoreRelaxed(newValue);
 }
 
-inline int QBasicAtomicInt::fetchAndAddRelaxed(int valueToAdd)
+inline int QBasicAtomicInt::fetchAndStoreOrdered(int newValue)
 {
-    return fetchAndAddOrdered(valueToAdd);
+    Q_DATA_MEMORY_BARRIER;
+    int returnValue = fetchAndStoreRelaxed(newValue);
+    Q_COMPILER_MEMORY_BARRIER;
+    return returnValue;
 }
 
+
 inline int QBasicAtomicInt::fetchAndAddAcquire(int valueToAdd)
 {
-    return fetchAndAddOrdered(valueToAdd);
+    int returnValue = fetchAndAddRelaxed(valueToAdd);
+    Q_DATA_MEMORY_BARRIER;
+    return returnValue;
 }
 
 inline int QBasicAtomicInt::fetchAndAddRelease(int valueToAdd)
 {
-    return fetchAndAddOrdered(valueToAdd);
+    Q_DATA_MEMORY_BARRIER;
+    return fetchAndAddRelaxed(valueToAdd);
 }
 
-template <typename T>
-Q_INLINE_TEMPLATE bool QBasicAtomicPointer<T>::testAndSetRelaxed(T *expectedValue, T *newValue)
+inline int QBasicAtomicInt::fetchAndAddOrdered(int valueToAdd)
 {
-    return testAndSetOrdered(expectedValue, newValue);
+    Q_DATA_MEMORY_BARRIER;
+    int returnValue = fetchAndAddRelaxed(valueToAdd);
+    Q_COMPILER_MEMORY_BARRIER;
+    return returnValue;
 }
 
 template <typename T>
 Q_INLINE_TEMPLATE bool QBasicAtomicPointer<T>::testAndSetAcquire(T *expectedValue, T *newValue)
 {
-    return testAndSetOrdered(expectedValue, newValue);
+    bool returnValue = testAndSetRelaxed(expectedValue, newValue);
+    Q_DATA_MEMORY_BARRIER;
+    return returnValue;
 }
 
 template <typename T>
 Q_INLINE_TEMPLATE bool QBasicAtomicPointer<T>::testAndSetRelease(T *expectedValue, T *newValue)
 {
-    return testAndSetOrdered(expectedValue, newValue);
+    Q_DATA_MEMORY_BARRIER;
+    return testAndSetRelaxed(expectedValue, newValue);
 }
 
 template <typename T>
-Q_INLINE_TEMPLATE T *QBasicAtomicPointer<T>::fetchAndStoreRelaxed(T *newValue)
+Q_INLINE_TEMPLATE bool QBasicAtomicPointer<T>::testAndSetOrdered(T *expectedValue, T *newValue)
 {
-    return fetchAndStoreOrdered(newValue);
+    Q_DATA_MEMORY_BARRIER;
+    bool returnValue = testAndSetAcquire(expectedValue, newValue);
+    Q_COMPILER_MEMORY_BARRIER;
+    return returnValue;
 }
 
 template <typename T>
 Q_INLINE_TEMPLATE T *QBasicAtomicPointer<T>::fetchAndStoreAcquire(T *newValue)
 {
-    return fetchAndStoreOrdered(newValue);
+    T *returnValue = fetchAndStoreRelaxed(newValue);
+    Q_DATA_MEMORY_BARRIER;
+    return returnValue;
 }
 
 template <typename T>
 Q_INLINE_TEMPLATE T *QBasicAtomicPointer<T>::fetchAndStoreRelease(T *newValue)
 {
-    return fetchAndStoreOrdered(newValue);
+    Q_DATA_MEMORY_BARRIER;
+    return fetchAndStoreRelaxed(newValue);
 }
 
 template <typename T>
-Q_INLINE_TEMPLATE T *QBasicAtomicPointer<T>::fetchAndAddRelaxed(qptrdiff valueToAdd)
+Q_INLINE_TEMPLATE T *QBasicAtomicPointer<T>::fetchAndStoreOrdered(T *newValue)
 {
-    return fetchAndAddOrdered(valueToAdd);
+    Q_DATA_MEMORY_BARRIER;
+    T *returnValue = fetchAndStoreRelaxed(newValue);
+    Q_COMPILER_MEMORY_BARRIER;
+    return returnValue;
 }
 
 template <typename T>
 Q_INLINE_TEMPLATE T *QBasicAtomicPointer<T>::fetchAndAddAcquire(qptrdiff valueToAdd)
 {
-    return fetchAndAddOrdered(valueToAdd);
+    T *returnValue = fetchAndAddRelaxed(valueToAdd);
+    Q_DATA_MEMORY_BARRIER;
+    return returnValue;
 }
 
 template <typename T>
 Q_INLINE_TEMPLATE T *QBasicAtomicPointer<T>::fetchAndAddRelease(qptrdiff valueToAdd)
 {
-    return fetchAndAddOrdered(valueToAdd);
+    Q_DATA_MEMORY_BARRIER;
+    return fetchAndAddRelaxed(valueToAdd);
 }
 
+template <typename T>
+Q_INLINE_TEMPLATE T *QBasicAtomicPointer<T>::fetchAndAddOrdered(qptrdiff valueToAdd)
+{
+    Q_DATA_MEMORY_BARRIER;
+    T *returnValue = fetchAndAddRelaxed(valueToAdd);
+    Q_COMPILER_MEMORY_BARRIER;
+    return returnValue;
+}
+
+#undef Q_DATA_MEMORY_BARRIER
+#undef Q_COMPILER_MEMORY_BARRIER
+
 QT_END_NAMESPACE
 
 QT_END_HEADER
