qt-bugs@ issue : none
Qt Software task ID : none
bugs.kde.org number : none
applied: no 
author: Fredrik HÃ¶glund <fredrik@kde.org>

This patch makes the raster graphics system use shared images instead
of shared pixmaps.

Shared memory pixmaps are deprecated since they are slower than shared
images with modern graphics hardware. They are also not supported by EXA
drivers and can be disabled in the latest version of the NVidia driver.

--- a/src/gui/image/qnativeimage_p.h
+++ b/src/gui/image/qnativeimage_p.h
@@ -90,7 +90,6 @@ public:
 
 #elif defined(Q_WS_X11) && !defined(QT_NO_MITSHM)
     XImage *xshmimg;
-    Pixmap xshmpm;
     XShmSegmentInfo xshminfo;
 
 #elif defined(Q_WS_MAC)
--- a/src/gui/image/qnativeimage.cpp
+++ b/src/gui/image/qnativeimage.cpp
@@ -147,7 +147,6 @@ QNativeImage::QNativeImage(int width, in
 {
     if (!X11->use_mitshm) {
         xshmimg = 0;
-        xshmpm = 0;
         image = QImage(width, height, format);
         return;
     }
@@ -191,11 +190,6 @@ QNativeImage::QNativeImage(int width, in
             shmctl(xshminfo.shmid, IPC_RMID, 0);
         return;
     }
-    xshmpm = XShmCreatePixmap(X11->display, DefaultRootWindow(X11->display), xshmimg->data,
-                              &xshminfo, width, height, dd);
-    if (!xshmpm) {
-        qWarning() << "QNativeImage: Unable to create shared Pixmap.";
-    }
 }
 
 
@@ -204,10 +198,6 @@ QNativeImage::~QNativeImage()
     if (!xshmimg)
         return;
 
-    if (xshmpm) {
-        XFreePixmap(X11->display, xshmpm);
-        xshmpm = 0;
-    }
     XShmDetach(X11->display, &xshminfo);
     xshmimg->data = 0;
     XDestroyImage(xshmimg);
--- a/src/gui/painting/qwindowsurface_raster.cpp
+++ b/src/gui/painting/qwindowsurface_raster.cpp
@@ -221,9 +221,16 @@ void QRasterWindowSurface::flush(QWidget
 
     QRect br = rgn.boundingRect().translated(offset);
 #ifndef QT_NO_MITSHM
-    if (d_ptr->image->xshmpm) {
-        XCopyArea(X11->display, d_ptr->image->xshmpm, widget->handle(), d_ptr->gc,
-                  br.x(), br.y(), br.width(), br.height(), wbr.x(), wbr.y());
+    if (d_ptr->image->xshmimg && (br.width() * br.height() > 65536)) {
+        const QImage &src = d->image->image;
+        br = br.intersected(src.rect());
+        // Hack to make sure we satisify the PutImage() constraints in the X server,
+        // since the doShmPutImage() route currently forces a migration to system ram.
+        wbr.setX(wbr.x() - br.x());
+        br.setX(0);
+        br.setWidth(src.width());
+        XShmPutImage(X11->display, widget->handle(), d_ptr->gc, d_ptr->image->xshmimg,
+                     br.x(), br.y(), wbr.x(), wbr.y(), br.width(), br.height(), False);
         XSync(X11->display, False);
     } else
 #endif
--- a/src/gui/kernel/qapplication_x11.cpp
+++ b/src/gui/kernel/qapplication_x11.cpp
@@ -1952,7 +1952,7 @@ void qt_init(QApplicationPrivate *priv, 
             // to determine whether the display is local or not (not 100 % accurate)
             bool local = displayName.isEmpty() || displayName.lastIndexOf(QLatin1Char(':')) == 0;
             if (local && (qgetenv("QT_X11_NO_MITSHM").toInt() == 0))
-                X11->use_mitshm = mitshm_pixmaps;
+                X11->use_mitshm = true;
         }
 #endif // QT_NO_MITSHM
 
